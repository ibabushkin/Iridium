Diese Software verwendet ein aus mehreren Schritten bestehendes Verfahren,
um das gesetzte Ziel zu erreichen. Dieser Ansatz ist gewählt worden, da er
nicht nur zufälligerweise der UNIX-Philosophie entspricht, sondern weil der
Autor glaubt, die Qualität der Software selbst und anderer Produkte, die
diese verwenden, so maximieren zu können. Dementsprechend soll es möglichst
einfach sein, die Software nur in Teilen zu verwenden und in anderen Kon-
texten einzusetzen. Folglich ist das grobe Design wie folgt:
der Analyseprozess wird in zwei große Schritte unterteilt: die eigentliche
Analyse disassemblierter Informationen, die ihre Erkenntnisse in einem
Metaformat spechert, welches getrennt geparst wird, so dass die Modularität
gewährleistet ist. Gleichzeitig erlaubt diese Unetrteilung ein einfaches
Hinzufügen neuer Features und andere Arten der Erweiterung.
Dieses Dokument soll eine komplette Spezifikation besagten Metaformats
darstellen und wird bei Bedarf aktualisiert und geändert, zumal die Soft-
ware sich noch im sehr frühen Alphastadium befindet.

Formatspezfikation v0.2:

Dokumente dieses Formats sind Assemblerlstings, die auf besondere Weise mit
Kommentaren versehen sind, die vom Formatparser verwendet werden, um eine
Annäherung an das entsprechende Listing in einer (imperativen) Hochsprache  
zu generieren. Im Folgenden werden syntaktische Einheiten des Formats als
Tokens bezeichnet. Jeder Token wird in einem Schritt vom Parser interpretiert
und seine Bedeutung ist in jedem Kontext eindeutig. Die Eigenschaften von
Verzweigungen in modernen Programmiersprachen legten nahe, eine Baumstruktur
zur Repräsentation der Gesamtheit der Strukturen eines Programms zu verwenden.
Folglich gibt es zwei Klassen von Strukturen: Welche, die durch einen Token
repräsentiert werden können, da sie keine weiteren Strukturen beinhalten ("Blatttokens")
und Strukturen, die eine variable Anzahl weiterer Strukturen beinhalten, also
explizit einen Anfang und ein Ende haben, also aus zwei Tokens bestehen ("Knotentokens").
Um diese beiden Kategorien zu unterscheiden, werden spezielle Schlüssewörter verwendet ("begin" und "end").
Jeder Token befindet sich in einer eigenen Zeile und besitzt das Prefix "; ",
was ihn als ASM-Kommentar identifiziert.

; bytes(40)                 ein Blatttoken

; begin if                  ein struktureröffnender Knotentoken

; end if                    ein strukturschließender Knotentoken

Wenn Parameter an ein Token übergeben weden müssen, geschieht dies mit
runden Klamern, ohne jeglichen Whitespace, wie im ersten Beispiel ersichtlich.

Referenz:

Blatttokens:

bytes(anzahl) : fügt Kommentar über allozierten Speicher, angegeben über
                den Parameter anzahl, ein.
                
Knotentokens:

func(name, return_type, args...) : Funktion
if : If-Struktur
elseif : Else-If-Struktur
else : Else-Block
loop : Schleife, derzet kein Suport für vor-/nachprüfende Schleifen
doloop : Nachprüfende Schleife, neu hinzugefügt ab v0.2
condition : Bedingung

Anmerkung: der aktuelle Parser verwendet einen Stack um alle aktuellen
Strukturen zu speichern. Folglich ist eine falsche abfolge von Strukturen
fatal für den Output.

Die if-, elseif- und loop-Strukturen erfordern als ersten Nachfolger
eine condition-, als zweiten (optionalen) eine code-Struktur.
Die doloop-Struktur erfordert 2 Nachfolger: eine code-Struktur und danach eine
condition-Struktur. Wichtig: Der Parser unterscheidet zwischen Conditions in
Nachprüfenden Schleifen und anderen Kontexten (s. Quellcode)

Auch wenn der Stack als Speicher für alle aktuellen Strukturen als Schwach-
stelle erscheint, ist er der sicherste und sinnvollste Weg, da er syntaktisch
richtigen Code per default generiert.
Zum Beispiel wäre eine solche Tokenabfolge nicht in validen Code zu übersetzen:

; begin loop

; begin condition
; end condition

; begin if

; begin condition
; end condition

; end loop

; end if

Der Parser würde trotzdem richtigen Code generieren:

while(){
    if(){
    
    }
}

Und das, obwohl keinerlei Heuristiken hinsichtlich malformatierter Daten 
implementiert wurden - "It works by design!"
