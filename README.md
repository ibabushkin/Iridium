# Iridium
Iridium is a decomposition framework for usage with the x86 family of Assembly
languages. It was designed to be easy-to use, effective and extensible. It is
divided into three modules, which maintain different parts of analysis.
Written completely in Python, it is intended for Reverse Engineers and Malware
Analysts who want to perform certain aspects of static analysis in an automated
fashion without "losing touch" with the binary's code.

## Features
* Analysis of control flow, using structural analysis.
  + Supports all HLL-constructs except `goto`, `break`, `continue`, altough support
    for them should be added in the future.
  + Analyzes complex conditions found in the code.
  + Presents the results in an easy-to-understand format, making it easy to rewrite
    the given program in any HLL if needed.
* Analysis of data found on the stack.
  + Applies a heuristic to determine which data is a variable, which size it has and
    whether it is a pointer or array.
* Analysis of optimized integer divisions.
  + Recovery of divisor from the source.
  + Interactive mode: Make the user input all needed constants and calculate
    the results.
* A separation between the modules, which makes it easy to implement new input
  methods or modules. Apart from that, the code is equally easy to integrate into
  already existing projects, or to use in part.

## Installation and usage
Iridium is written completely in Python. To use it, just make sure it is on your
`PYTHONPATH`. The concept I followed while developing it was to make sure the code
performing analysis is strictly separated from the code that parses the user's input
etc. At the moment, only one way of feeding data to Iridium is present, but that is
to be changed in the near future.

To make use of all the features, `cd` into the project's root and run
`python IDAIridium.py <file>`, where `<file>` is an Assembly listing generated by IDA Pro.
This will split the code into functions and analyze them seperately, saving the results
on disk. If you already have a `.asm`-file that contains only one function, you can
simply run one of the modules as a script, providing the file as an argument. The modules
are the same as used by `IDAIridium.py` and are stored in the `defines`-tree. For more
information, see their documentation by running `python <module> -h`.
At the moment, this is the only way to analyze a complete binary, more are likely to follow.
You can use the free version of IDA Pro, as I do, the behaviour with more current releases
isn't tested yet.

An example: you want to run controlflow-analysis on a file containing one function in assembly.
In this case, do this, I assume that you're in the project's root:
```sh
$ cd defines/cfg
$ python analyzer.py -h
usage: analyzer.py [-h] [-s SOURCE] [-o OUTPUT]

The controlflow analysis module, capable to work stand-alone

optional arguments:
  -h, --help            show this help message and exit
  -s SOURCE, --source SOURCE
                        Optional file to be analyzed, if not present, the
                        hard-coded-default is used (for debugging purposes)
  -o OUTPUT, --output OUTPUT
                        Optional file to redirect input to

$ python analyzer.py <path_to_your_file>
*output comes here*
```

## Extending
To write modules that accept other kinds of input than just `.asm`-files generated by
IDA Pro, I recommend following the structure of `IDAIridium.py`. More information etc.
is likely to follow, since I plan to write other input-parsing-modules as well.

## TODO
There are some minor bugs and quirks in the code, but they should not affect the program
in a serious way. Still, if found such behaviour should get an issue. Apart from that, there
are some issues still not implemented:
* Support for `break`, `continue` etc.
* Better output in case the analysis did fail
* more input methods
  + PE/ELF standalone analysis via pefile and Capstone etc.
  + `IDAPython` integration
* A function blacklist for `IDAIridium.py` and similar modules
* Some bugfixes
  + Sometimes complex conditions in `if-then-else` structures are not
    recognized properly, because their edges leading to the `then` or 
    `else` part are reduced pseudo-randomly. Probably hard to fix, but
    sometimes annoying and slowing down.
  + make the project more usable
