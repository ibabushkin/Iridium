# Iridium
Iridium is a decomposition framework for usage with the x86 family of Assembly
languages. It was designed to be easy-to use, effective and extensible. It is
divided into three modules, which maintain different parts of analysis.
Written completely in Python, it is intended for Reverse Engineers and Malware
Analysts who want to perform certain aspects of static analysis in an automated
fashion without "losing touch" with the binary's code.

## Features
* Analysis of control flow, using structural analysis.
  + Supports all HLL-constructs except `goto`, `break`, `continue`, altough support
    for them should be added in the future.
  + Analyzes complex conditions found in the code.
  + Presents the results in an easy-to-understand format, making it easy to rewrite
    the given program in any HLL if needed.
* Analysis of data found on the stack.
  + Applies heuristics to determine which data is a variable, which size it has and
    whether it is a pointer or array.
* Analysis of optimized integer divisions.
  + Recovery of divisor from the source.
  + Interactive mode: Make the user input all needed constants and calculate
    the results.
* A separation between the modules, which makes it easy to implement new input
  methods or modules. Apart from that, the code is equally easy to integrate into
  already existing projects, or to use in part.

## Installation and usage
Iridium is written completely in Python. To use it, just make sure it is on your
`PYTHONPATH`. The concept I followed while developing it was to make sure the code
performing analysis is strictly separated from the code that parses the user's input
etc. The default input module uses `.asm`-files generated by IDA Pro (Free) and can
be used without any further preparations.

To make use of all the features, `cd` into the project's root and run
`python IDAIridium.py <file>`, where `<file>` is an Assembly listing generated by IDA Pro.
This will split the code into functions and analyze them seperately, saving the results
on disk. If you already have a `.asm`-file that contains only one function, you can
simply run one of the modules as a script, providing the file as an argument. The modules
are the same as used by `IDAIridium.py` and are stored in the `defines`-tree. For more
information, see their documentation by running `python <module> -h`.
At the moment, this is the only way to analyze a complete binary, more are likely to follow.
You can use the free version of IDA Pro, as I do, the behaviour with more current releases
isn't tested yet.

An example: you want to run controlflow-analysis on a file containing one function in assembly.
In this case, do this, I assume that you're in the project's root:
```sh
$ cd defines/cfg
$ python analyzer.py -h
usage: analyzer.py [-h] [-s SOURCE] [-o OUTPUT]

The controlflow analysis module, capable to work stand-alone

optional arguments:
  -h, --help            show this help message and exit
  -s SOURCE, --source SOURCE
                        Optional file to be analyzed, if not present, the
                        hard-coded-default is used (for debugging purposes)
  -o OUTPUT, --output OUTPUT
                        Optional file to redirect input to

$ python analyzer.py <path_to_your_file>
*output comes here*
```

However, this is often not the best solution. Thus, other input methods are under
development or planned. Currently, a gdb plugin is present. To install it, add the
following line to your `.gdbinit`:
```
source <install prefix>/Iridium/GDBIridium.py
```
Apart from that I recommend to disable pagination:
```
set pagination off
```
Inside gdb, you can invoke Iridium's modules by issuing the command `iridium`.
```
# show an assembly listing as iridium uses it internally
gdb-peda$ iridium main
push ebp
mov ebp,esp
and esp,0xfffffff0
sub esp,0x20
mov DWORD PTR [esp+0x1c],0x0
add DWORD PTR [esp+0x1c],0x1
<main+17>:
cmp DWORD PTR [esp+0x1c],0x2
jne <main+41>
mov DWORD PTR [esp],0x804864c
call 0x8048360 <printf@plt>
mov eax,DWORD PTR [esp+0x1c]
<main+41>:
cdq
shr edx,0x1f
add eax,edx
and eax,0x1
sub eax,edx
cmp eax,0x1
jne <main+73>
mov DWORD PTR [esp],0x8048650
call 0x8048360 <printf@plt>
<main+73>:
mov DWORD PTR [esp],0x8048655
call 0x8048360 <printf@plt>
cmp DWORD PTR [esp+0x1c],0x1
jle <main+17>
leave
ret
```
Or use the commands `iridium cfg`, `iridium data`, `iridium div` to invoke the individual
modules on a function.

## Extending
To write modules that accept other kinds of input than just `.asm`-files generated by
IDA Pro, I recommend following the structure of `IDAIridium.py`, at least if you want
to provide an enviroment for automated analysis of a whole binary file. If you want to
create some kind of plugin for a disassembler or debugger, I suggest inspecting the
structure of `GDBIridium.py` 

## TODO
There are some minor bugs and quirks in the code, but they should not affect the program
in a serious way. Still, if found such behaviour should get an issue. Apart from that, there
are some issues still not implemented:
* Support for `break`, `continue` etc.
* Better output in case the analysis did fail - partly done
* more input methods
  + PE/ELF standalone analysis via pefile and Capstone etc.
  + `IDAPython` integration
* Some bugfixes
  + Sometimes complex conditions in `if-then-else` structures are not
    recognized properly, because their edges leading to the `then` or 
    `else` part are reduced pseudo-randomly. Probably hard to fix, but
    sometimes annoying and slowing down.
